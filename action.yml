name: "Build and Push to Ryvn Registry"
description: "Builds and pushes Docker images or Helm charts to Ryvn Registry"

inputs:
  service_name:
    description: "Name of the service"
    required: true
  version:
    description: "Semantic version to tag the image/chart with"
    required: true
  build_only:
    description: "Build only, don't push to registry"
    required: false
    default: "false"
  ryvn_client_id:
    description: "Ryvn Client ID for authentication"
    required: true
  ryvn_client_secret:
    description: "Ryvn Client Secret for authentication"
    required: true
  build_args:
    description: "Build arguments to pass to the Docker build"
    required: false
  platforms:
    description: "List of target platforms for build"
    required: false
    default: "linux/amd64"
  use_nixpacks:
    description: "Use Nixpacks to build Docker images instead of Dockerfile"
    required: false
    default: "false"
  nixpacks_pkgs:
    description: "Additional Nix packages to install in the environment"
    required: false
    default: ""
  nixpacks_apt:
    description: "Additional Apt packages to install in the environment"
    required: false
    default: ""
  nixpacks_cache:
    description: "Use the Nixpacks build cache"
    required: false
    default: "true"
  buildx_endpoint:
    description: "Docker Buildx endpoint for remote driver"
    required: false
    default: ""
  buildx_driver:
    description: "Docker Buildx driver type"
    required: false
    default: ""
  disable_cache:
    description: "Disable all caching (GitHub Actions cache and build cache)"
    required: false
    default: "false"

runs:
  using: "composite"
  steps:
    - name: Install Ryvn CLI
      uses: ryvn-technologies/install-ryvn-cli@v1.0.0

    - name: Print Runner Info
      shell: bash
      run: |
        echo "Runner name: ${{ runner.name }}"
        echo "Runner OS: ${{ runner.os }}"
        echo "Runner architecture: ${{ runner.arch }}"
        echo "Runner labels: ${{ runner.labels }}"

    - name: Get Service and Registry Details from Ryvn API
      id: service
      shell: bash
      env:
        RYVN_CLIENT_ID: ${{ inputs.ryvn_client_id }}
        RYVN_CLIENT_SECRET: ${{ inputs.ryvn_client_secret }}
      run: |
        # Get service details
        ryvn get service ${{ inputs.service_name }} -o json > service.json

        echo "Service details: $(cat service.json)"

        # Extract and validate service type
        service_type=$(jq -r '.definition.type' service.json)
        if [ "$service_type" = "null" ] || [ -z "$service_type" ]; then
          echo "Error: service type not found in service definition"
          exit 1
        fi

        # Extract and validate working directory
        working_dir=$(jq -r '.definition.build.workingDir' service.json)
        if ([ "$working_dir" = "null" ] || [ -z "$working_dir" ]) && ([ "$service_type" = "web-server.v1" ] || [ "$service_type" = "job.v1" ]); then
          echo "Error: working_dir not found in service definition"
          exit 1
        fi

        # Extract build command and buildpack for nixpacks first
        build_command=$(jq -r '.definition.build.command // ""' service.json)
        buildpack=$(jq -r '.definition.build.buildpack' service.json)

        # Extract and validate dockerfile path (only required if not using buildpack/nixpacks)
        dockerfile_path=$(jq -r '.definition.build.dockerfilePath' service.json)
        if ([ "$dockerfile_path" = "null" ] || [ -z "$dockerfile_path" ]) && ([ "$service_type" = "web-server.v1" ] || [ "$service_type" = "job.v1" ]) && [ "${{ inputs.use_nixpacks }}" != "true" ] && [ "$buildpack" != "nixpack" ]; then
          echo "Error: dockerfile_path not found in service definition"
          exit 1
        fi

        # Check if service should use nixpacks
        use_nixpacks_from_service="false"
        if [ "$buildpack" = "nixpack" ]; then
          use_nixpacks_from_service="true"
        fi

        # Check if dockerBuildArgs exists and is not null
        if [ "$(jq -r '.definition.build.dockerBuildArgs != null' service.json)" = "true" ]; then
          # Extract and convert build args to multi-line format
          service_build_args=$(jq -r '.definition.build.dockerBuildArgs | to_entries | map("\(.key)=\(.value)") | join("\n")' service.json)
          # If workflow build args are not specified, use service build args
          if [ -z "${{ inputs.build_args }}" ]; then
            echo "Using build args from service definition"
            echo "build_args<<EOF" >> $GITHUB_OUTPUT
            echo "$service_build_args" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "Using build args from workflow input"
            echo "build_args=${{ inputs.build_args }}" >> $GITHUB_OUTPUT
          fi
        else
          echo "build_args=${{ inputs.build_args }}" >> $GITHUB_OUTPUT
        fi

        # Extract and validate image name
        image_name=$(jq -r '.definition.imageName' service.json)
        if ([ "$image_name" = "null" ] || [ -z "$image_name" ]) && ([ "$service_type" = "web-server.v1" ] || [ "$service_type" = "job.v1" ]); then
          echo "Error: imageName not found in service definition"
          exit 1
        fi

        # Extract and validate helm chart path
        helm_chart_path=$(jq -r '.definition.build.chartPath' service.json)
        if ([ "$helm_chart_path" = "null" ] || [ -z "$helm_chart_path" ]) && [ "$service_type" = "helm-chart.v1" ]; then
          echo "Error: chartPath not found in service definition"
          exit 1
        fi

        # Extract chart name
        chart_name=$(jq -r '.definition.chartName' service.json)
        if ([ "$chart_name" = "null" ] || [ -z "$chart_name" ]) && [ "$service_type" = "helm-chart.v1" ]; then
          echo "Error: chartName not found in service definition"
          exit 1
        fi

        chart_repo=$(jq -r '.definition.chartRepository' service.json)
        if ([ "$chart_repo" = "null" ] || [ -z "$chart_repo" ]) && [ "$service_type" = "helm-chart.v1" ]; then
          echo "Error: chartRepository not found in service definition"
          exit 1
        fi

        # Extract and validate orgId
        org_id=$(jq -r '.orgId' service.json)
        if [ "$org_id" = "null" ] || [ -z "$org_id" ]; then
          echo "Error: orgId not found in service definition"
          exit 1
        fi

        # Extract registry from service definition
        registry_name=$(jq -r '.definition.registry // "ryvn-registry"' service.json)

        # Determine registry URL and credentials based on registry name
        if [ "$registry_name" = "ryvn-registry" ] || [ "$registry_name" = "null" ] || [ -z "$registry_name" ]; then
          # Use default hardcoded registry for ryvn-registry
          echo "Using default ryvn-registry"
          registry_type="elasticContainerRegistry"
          registry_url="703671917981.dkr.ecr.us-east-1.amazonaws.com"
          role_arn="arn:aws:iam::703671917981:role/${org_id}-github-actions"
          region="us-east-1"
          registry_username=""
          registry_password=""
        else
          # Fetch registry details from Ryvn API
          echo "Fetching registry details for: $registry_name"
          ryvn get registry "$registry_name" -o json > registry.json

          echo "Registry details: $(cat registry.json)"

          # Extract registry type
          registry_type=$(jq -r '.definition.type' registry.json)
          if [ "$registry_type" = "null" ] || [ -z "$registry_type" ]; then
            echo "Error: Registry type not found for registry: $registry_name"
            exit 1
          fi

          # Extract registry URL
          registry_url=$(jq -r '.definition.url' registry.json)
          if [ "$registry_url" = "null" ] || [ -z "$registry_url" ]; then
            echo "Error: Registry URL not found for registry: $registry_name"
            exit 1
          fi

          # Extract credentials based on registry type
          if [ "$registry_type" = "elasticContainerRegistry" ]; then
            # ECR registry - extract role ARN and region
            role_arn=$(jq -r '.definition.credentials.roleArn' registry.json)
            if [ "$role_arn" = "null" ] || [ -z "$role_arn" ]; then
              echo "Error: Role ARN not found for ECR registry: $registry_name"
              exit 1
            fi

            region=$(jq -r '.definition.region' registry.json)
            if [ "$region" = "null" ] || [ -z "$region" ]; then
              echo "Error: Region not found for ECR registry: $registry_name"
              exit 1
            fi

            registry_username=""
            registry_password=""

            echo "Using ECR registry: $registry_name"
            echo "Registry URL: $registry_url"
            echo "Region: $region"
          elif [ "$registry_type" = "genericContainerRegistry" ]; then
            # Generic registry - extract basic auth credentials
            registry_username=$(jq -r '.definition.credentials.username' registry.json)
            if [ "$registry_username" = "null" ] || [ -z "$registry_username" ]; then
              echo "Error: Username not found for generic registry: $registry_name"
              exit 1
            fi

            registry_password=$(jq -r '.definition.credentials.password' registry.json)
            if [ "$registry_password" = "null" ] || [ -z "$registry_password" ]; then
              echo "Error: Password not found for generic registry: $registry_name"
              exit 1
            fi

            role_arn=""
            region=""

            echo "Using generic container registry: $registry_name"
            echo "Registry URL: $registry_url"
          else
            echo "Error: Unknown registry type: $registry_type"
            exit 1
          fi
        fi

        # Set outputs
        echo "service_type=$service_type" >> $GITHUB_OUTPUT
        echo "helm_chart_path=$helm_chart_path" >> $GITHUB_OUTPUT
        echo "chart_name=$chart_name" >> $GITHUB_OUTPUT
        echo "chart_repo=$chart_repo" >> $GITHUB_OUTPUT
        echo "working_dir=$working_dir" >> $GITHUB_OUTPUT
        echo "dockerfile_path=$dockerfile_path" >> $GITHUB_OUTPUT
        echo "registry_type=$registry_type" >> $GITHUB_OUTPUT
        echo "registry_url=$registry_url" >> $GITHUB_OUTPUT
        echo "role_arn=$role_arn" >> $GITHUB_OUTPUT
        echo "region=$region" >> $GITHUB_OUTPUT
        echo "registry_username=$registry_username" >> $GITHUB_OUTPUT
        echo "registry_password=$registry_password" >> $GITHUB_OUTPUT
        echo "image_name=$image_name" >> $GITHUB_OUTPUT
        echo "build_command=$build_command" >> $GITHUB_OUTPUT
        echo "use_nixpacks_from_service=$use_nixpacks_from_service" >> $GITHUB_OUTPUT

    - name: Configure AWS credentials
      if: inputs.build_only != 'true' && steps.service.outputs.registry_type == 'elasticContainerRegistry'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ steps.service.outputs.role_arn }}
        aws-region: ${{ steps.service.outputs.region }}

    - name: Login to Amazon ECR
      if: inputs.build_only != 'true' && steps.service.outputs.registry_type == 'elasticContainerRegistry'
      uses: aws-actions/amazon-ecr-login@v2

    - name: Login to Generic Container Registry
      if: inputs.build_only != 'true' && steps.service.outputs.registry_type == 'genericContainerRegistry'
      uses: docker/login-action@v3
      with:
        registry: ${{ steps.service.outputs.registry_url }}
        username: ${{ steps.service.outputs.registry_username }}
        password: ${{ steps.service.outputs.registry_password }}

    # Docker Image Steps
    - name: Extract Docker metadata
      if: steps.service.outputs.service_type == 'web-server.v1' || steps.service.outputs.service_type == 'job.v1'
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ steps.service.outputs.registry_url }}/${{ steps.service.outputs.image_name }}
        tags: |
          type=semver,pattern={{version}},value=${{ inputs.version }}
          type=sha
          type=ref,event=pr

    # Nixpacks Build and Push (with build command)
    - name: Build and push with Nixpacks (with build command)
      if: (steps.service.outputs.service_type == 'web-server.v1' || steps.service.outputs.service_type == 'job.v1') && (inputs.use_nixpacks == 'true' || steps.service.outputs.use_nixpacks_from_service == 'true') && steps.service.outputs.build_command != ''
      uses: iloveitaly/github-action-nixpacks@main
      with:
        context: ${{ steps.service.outputs.working_dir }}
        push: ${{ inputs.build_only != 'true' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: ${{ inputs.platforms }}
        pkgs: ${{ inputs.nixpacks_pkgs }}
        apt: ${{ inputs.nixpacks_apt }}
        cache: ${{ inputs.disable_cache == 'true' && 'false' || inputs.nixpacks_cache }}
        cache_tag: ${{ steps.service.outputs.registry_url }}/${{ steps.service.outputs.image_name }}:cache
        env: NIXPACKS_BUILD_CMD="${{ steps.service.outputs.build_command }}"

    # Nixpacks Build and Push (without build command)
    - name: Build and push with Nixpacks (without build command)
      if: (steps.service.outputs.service_type == 'web-server.v1' || steps.service.outputs.service_type == 'job.v1') && (inputs.use_nixpacks == 'true' || steps.service.outputs.use_nixpacks_from_service == 'true') && steps.service.outputs.build_command == ''
      uses: iloveitaly/github-action-nixpacks@main
      with:
        context: ${{ steps.service.outputs.working_dir }}
        push: ${{ inputs.build_only != 'true' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: ${{ inputs.platforms }}
        pkgs: ${{ inputs.nixpacks_pkgs }}
        apt: ${{ inputs.nixpacks_apt }}
        cache: ${{ inputs.disable_cache == 'true' && 'false' || inputs.nixpacks_cache }}
        cache_tag: ${{ steps.service.outputs.registry_url }}/${{ steps.service.outputs.image_name }}:cache
        env: ${{ steps.service.outputs.build_args }}

    # Standard Docker Build Steps - only run if not using Nixpacks
    - name: Set up Docker Buildx (Blacksmith)
      if: (steps.service.outputs.service_type == 'web-server.v1' || steps.service.outputs.service_type == 'job.v1') && startsWith(runner.name, 'blacksmith') && inputs.use_nixpacks != 'true' && steps.service.outputs.use_nixpacks_from_service != 'true'
      uses: useblacksmith/setup-docker-builder@v1

    - name: Set up Docker Buildx (Docker)
      if: (steps.service.outputs.service_type == 'web-server.v1' || steps.service.outputs.service_type == 'job.v1') && !startsWith(runner.name, 'blacksmith') && inputs.use_nixpacks != 'true' && steps.service.outputs.use_nixpacks_from_service != 'true'
      uses: docker/setup-buildx-action@v3
      with:
        version: latest
        endpoint: ${{ inputs.buildx_endpoint }}
        driver: ${{ inputs.buildx_driver }}

    - name: Build and push Docker image (Blacksmith)
      if: (steps.service.outputs.service_type == 'web-server.v1' || steps.service.outputs.service_type == 'job.v1') && startsWith(runner.name, 'blacksmith') && inputs.use_nixpacks != 'true' && steps.service.outputs.use_nixpacks_from_service != 'true'
      uses: useblacksmith/build-push-action@v2
      with:
        context: ${{ steps.service.outputs.working_dir }}
        file: ${{ steps.service.outputs.dockerfile_path }}
        push: ${{ inputs.build_only != 'true' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: ${{ steps.service.outputs.build_args }}
        platforms: ${{ inputs.platforms }}

    - name: Build and push Docker image (Docker)
      if: (steps.service.outputs.service_type == 'web-server.v1' || steps.service.outputs.service_type == 'job.v1') && !startsWith(runner.name, 'blacksmith') && inputs.use_nixpacks != 'true' && steps.service.outputs.use_nixpacks_from_service != 'true'
      uses: docker/build-push-action@v5
      with:
        context: ${{ steps.service.outputs.working_dir }}
        file: ${{ steps.service.outputs.dockerfile_path }}
        push: ${{ inputs.build_only != 'true' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: ${{ steps.service.outputs.build_args }}
        cache-from: ${{ inputs.disable_cache != 'true' && format('type=gha,scope={0}', inputs.service_name) || '' }}
        cache-to: ${{ inputs.disable_cache != 'true' && format('type=gha,mode=max,scope={0}', inputs.service_name) || '' }}
        platforms: ${{ inputs.platforms }}

    # Helm Chart Steps
    - name: Install Helm
      if: steps.service.outputs.service_type == 'helm-chart.v1'
      uses: azure/setup-helm@v3
      with:
        version: v3.12.1

    - name: Package Helm Chart
      if: steps.service.outputs.service_type == 'helm-chart.v1'
      shell: bash
      run: |
        helm package ${{ steps.service.outputs.helm_chart_path }} --version ${{ inputs.version }}

    - name: Login to Helm Registry (ECR)
      if: steps.service.outputs.service_type == 'helm-chart.v1' && inputs.build_only != 'true' && steps.service.outputs.registry_type == 'elasticContainerRegistry'
      shell: bash
      run: |
        aws ecr get-login-password --region ${{ steps.service.outputs.region }} | helm registry login --username AWS --password-stdin ${{ steps.service.outputs.registry_url }}

    - name: Login to Helm Registry (Generic)
      if: steps.service.outputs.service_type == 'helm-chart.v1' && inputs.build_only != 'true' && steps.service.outputs.registry_type == 'genericContainerRegistry'
      shell: bash
      run: |
        echo "${{ steps.service.outputs.registry_password }}" | helm registry login --username ${{ steps.service.outputs.registry_username }} --password-stdin ${{ steps.service.outputs.registry_url }}

    - name: Push Helm Chart to Registry
      if: steps.service.outputs.service_type == 'helm-chart.v1' && inputs.build_only != 'true'
      shell: bash
      run: |
        helm push ${{ steps.service.outputs.chart_name }}-${{ inputs.version }}.tgz oci://${{ steps.service.outputs.registry_url }}/${{ steps.service.outputs.chart_repo }}

branding:
  icon: "package"
  color: "blue"
